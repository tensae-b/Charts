<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <link rel="stylesheet" href="graph.css">
    <script src=" https://cdn.jsdelivr.net/npm/echarts@5.6.0/dist/echarts.min.js "></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>visualize</title>

</head>

<body>
    <div class="chart">
        <h1>User Profile Chart</h1>
        <div id="user-charts">
            <div class="reputation-chart">
                <div class="user-catergorical-reputation-data-chart">
                    <div id="user-catergorical-reputation-data" style="height: 500px"></div>
                </div>
                <div class="network-analysis-reputation-score-percentage-for-user">
                    <div id="network-analysis-reputation-score-percentage" style=" height: 500px;">

                    </div>
                </div>
            </div>
         
            <div class="user-expertise-level-and-user-nature-chart">
                <div id="user-expertise-level-and-user-nature" style="height: 500px"></div>
            </div>
            <div class="mpxr-from-interaction-percentage-chart">
                <div id="mpxr-from-interaction-percentage" style="height: 500px;"></div>
            </div>
            <div class="mpxr-from-rewards-chart">
                <div id="mpxr-from-rewards" style=""> </div>
            </div>
            <div class="content-consumption-breakdown-chart">
                <div id="content-consumption-breakdown" style="height: 500px;"> </div>
            </div>
            <div class="timespent-by-category-chart">
                <div id="timespent-by-category" style=" height: 1000px;"> </div>
            </div>

            <div class="mpxr-from-publication-chart">
                <div id="mpxr-from-publication" style="height: 1000px;"> </div>
            </div>
            <div class="association-breakdown-chart">
                <div id="association-breakdown" style=" height: 500px;"> </div>
            </div>
            <div class="interaction-breakdown-lists-chart">
                <div id="interaction-breakdown-lists" style="height: 700px;"> </div>
            </div>
            
        </div>
    </div>
    </div>
    <script>

        let userSelectors = {
            categoricalReputationBreakdown: document.getElementById(
                "user-catergorical-reputation-data"
            ),
            networkReputationScore: document.getElementById(
                "network-analysis-reputation-score-percentage"
            ),
            // numberMpxrPublication: document.getElementById(
            //     "number-of-MPXR-from-publication-for-user"
            // ),
            userNature: document.getElementById(
                "user-expertise-level-and-user-nature"
            ),
            interactionBreakdownNumbers: document.getElementById(
                "interaction-breakdown-in-numbers-users-favorite"
            ),
            mpxrFromInteractionPercentage: document.getElementById(
                "mpxr-from-interaction-percentage"
            ),
            mpxrFromRewards: document.getElementById(
                "mpxr-from-rewards"
            ),
            contentConsumptionBreakdown: document.getElementById(
                "content-consumption-breakdown"
            ),
            timeSpentByCategory: document.getElementById(
                "timespent-by-category"
            ),

            mpxrFromPublication: document.getElementById(
                "mpxr-from-publication"
            ),
            associationBreakdown: document.getElementById(
                "association-breakdown"
            ),
            interactionBreakdownLists: document.getElementById(
                "interaction-breakdown-lists"
            ),
        }
       
        let users = [
            {
                "user": 2,
                "mpxr": 3.50056,
                "vote_rep_availabe": 3.50055665,
                "public_address": null,
                "shared_rep": 0.0,
                "categories": [
                    {
                        "category": "3D Printing",
                        "rep": 0.8333333333333333
                    },
                    {
                        "category": "Aged Care",
                        "rep": 0.8333333333333333
                    },
                    {
                        "category": "AI",
                        "rep": 0.83333333
                    }
                ],
                "user_read_time": 12.0,
                "read_count": 3,
                "User Nature": {
                    "user nature": "Audience user",
                    "number of published articles": 0
                },
                "Total User Interaction Breakdown": {
                    "Total User Number of Interactions": {
                        "Total Interaction": 7,
                        "Total Positive Interactions": 5,
                        "Total Negative Interactions": 2,
                        "Total Neutral Interactions": 0
                    },
                    "Total User Percentage of Interactions": {
                        "time_spent": 42.857142857142854,
                        "peoples_choise": 14.285714285714285,
                        "comment": 14.285714285714285,
                        "like": 14.285714285714285,
                        "dislike": 14.285714285714285
                    }
                },
                "User Level": "Average Audience",
                "Association Breakdown": {
                    "Friend Relationship": {
                        "Immediate MPXR": 5.0,
                        "Monthly MPXR": 10.0
                    },
                    "Follow Relationship": {
                        "Monthly MPXR": 3.0
                    }
                },
                "Reputation Score Breakdown by number": {
                    "MPXR Total From Interaction": {
                        "MPXR From": 1.3499047381847757,
                    },
                    "MPXR From Time Spent": 0.030580181818400012,
                    "MPXR From people's Choice": 0,
                    "MPXR From Comment": {
                        "MPXR By": 0.0009277500000000001,
                        "MPXR From": 0.00018555
                    },
                    "MPXR From Publication": {
                        "text": {
                            "MPXR From": 0.9170792921788036,
                            "MPXR By": 0
                        },
                        "audio": {
                            "MPXR From": 0.03262623916172029,
                            "MPXR By": 0
                        },
                        "video": {
                            "MPXR From": 0.0,
                            "MPXR By": 0
                        }
                    },
                    "MPXR From Social Post": {
                        "MPXR From": 0.11972866838785647,
                        "MPXR By": 0.4
                    },
                    "MPXR From Login": {
                        "From Daily": 14.999999999999963,
                        "Straight Bonus": 0.0
                    }
                },
                "Network Breakdown": {
                    "Source of Positive MPXR Score": {
                        "Expert Audience": 10,
                        "Advanced Audience": 50,
                        "Intermediate Audience": 50,
                        "Average Audience": 30
                    },
                    "Source of Negative MPXR Score": {
                        "Expert Audience": 20,
                        "Advanced Audience": 80,
                        "Intermediate Audience": 40,
                        "Average Audience": 5,
                    }
                },
                "Content Consumption Breakdown": {
                    "articles/text": {
                        "total": 3,
                        "completed": 3,
                        "more_than_half": 30,
                        "less_than_half": 0,
                        "completed_percentage": 1.0,
                        "more_than_half_percentage": 100.0,
                        "less_than_half_percentage": 10.0
                    },
                    "podcasts/audio": {
                        "total": 2,
                        "completed": 3,
                        "more_than_half": 4,
                        "less_than_half": 5,
                        "completed_percentage": 6,
                        "more_than_half_percentage": 7,
                        "less_than_half_percentage": 8
                    },
                    "video": {
                        "total": 1,
                        "completed": 2,
                        "more_than_half": 3,
                        "less_than_half": 4,
                        "completed_percentage": 5,
                        "more_than_half_percentage": 6,
                        "less_than_half_percentage": 7
                    }
                },
                "User Categorical read time Breakdown": [
                    {
                        "category": "3D Printing",
                        "percentage of spent time": 33.33333337777778
                    },
                    {
                        "category": "Aged Care",
                        "percentage of spent time": 33.33333337777778
                    },
                    {
                        "category": "AI",
                        "percentage of spent time": 33.33333324444445
                    }
                ],
                "User Categorical Reputation from Time-Spent interaction": [
                    {
                        "category": "3D Printing",
                        "reputation": 1.5,
                        "percentage": 33.33333337777778
                    },
                    {
                        "category": "Aged Care",
                        "reputation": 1.5,
                        "percentage": 33.33333337777778
                    },
                    {
                        "category": "AI",
                        "reputation": 1.5,
                        "percentage": 33.33333324444445
                    }
                ],
                "Interaction Breakdown Lists": {
                    "User Emoji Interaction By Type Percentage Breakdown": {
                        "Emoji Reaction Breakdown": {
                            "Positive Reaction": {
                                "This content is perfect!": 46.15384615384615,
                                "This content is excellent!": 8.461538461538462,
                                "This Content is very good.": 9.230769230769232,
                                "This content is well done.": 9.230769230769232,
                                "This content is at least interesting.": 5.384615384615385,
                                "This content is not bad.": 12.307692307692308
                            },
                            "Negative Reaction": {
                                "This content is useless and mostly wrong": 0.7692307692307693,
                                "This content is so bad.": 0.7692307692307693,
                                "This content has some errors.": 2.307692307692308,
                                "This content is provocative and might be factually and logically wrong.": 0.0,
                                "This content is boring.": 1.5384615384615385,
                                "This content is badly presented.": 3.8461538461538463
                            }
                        }
                    },
                    "User Comment Interaction By Type Percentage Breakdown": {
                        "User Comment Interaction Percentages Breakdown": {
                            "Percentage of Comment": {
                                "Percentage of All Best": 6.25,
                                "Percentage of All Good": 12.5,
                                "Percentage of All Average": 56.25,
                                "Percentage of All Expedient": 12.5,
                                "Percentage of Hate Speech": 12.5,
                                "Percentage of Bullying": 0.0,
                                "Percentage of Vulgar": 0.0,
                                "Percentage of Spamming": 0.0
                            }
                        }
                    },
                    "User Like Interaction By Type Breakdown": {
                        "User Like Interaction By Type": {
                            "Percentages": {
                                "Percentage of Thumbs Up": 93.49112426035504,
                                "Percentage of Thumbs Down": 6.508875739644971
                            },
                            "Breakdown by Quality": {
                                "Percentage of Thumbs Up": {
                                    "No. of Best Quality Int.": 6,
                                    "No. of Good Quality Int.": 1,
                                    "No. of Average Quality Int.": 5,
                                    "No. of Low Quality Int.": 146
                                },
                                "Percentage of Thumbs Down": {
                                    "No. of Best Quality Int.": 0,
                                    "No. of Good Quality Int.": 0,
                                    "No. of Average Quality Int.": 0,
                                    "No. of Low Quality Int.": 11
                                }
                            }
                        }
                    },
                    "User Interaction by Quality Breakdown": {
                        "User Interaction by Quality Breakdown": {
                            "No. of Best Quality Int.": 12,
                            "No. of Good Quality Int.": 13,
                            "No. of Average Quality Int.": 12,
                            "No. of Low Quality Int.": 308
                        }
                    }
                }
            }
        ]


        
        // functions for user graphs//
        const categoricalReputationBreakdown = (data) => {

            const chart = echarts.init(userSelectors.categoricalReputationBreakdown);
            const seriesData = []
            const legendData = []

            data.forEach(item => {
                seriesData.push({
                    name: item.category,
                    value: item.rep
                });
                legendData.push({
                    name: item.category,
                })
            });

            option = {
                title: {
                    text: 'User Categorical reputation Breakdown',

                    left: 'center',
                    textStyle: {
                        color: '#fff'
                    }
                },
                tooltip: {
                    trigger: 'item',
                    formatter: ' ({d}%)'
                },
                label: {
                    color: '#fff'
                },
                legend: {
                    type: 'scroll',
                    orient: 'vertical',
                    right: 0,
                    top: 25,
                    bottom: 20,
                    data: legendData,
                    textStyle: {
                        color: '#fff'
                    }
                },
                series: [
                    {
                        name: 'reputation Breakdown',
                        type: 'pie',
                        radius: '50%',

                        data: seriesData,
                        emphasis: {
                            itemStyle: {
                                shadowBlur: 10,
                                shadowOffsetX: 0,
                                shadowColor: 'rgba(0, 0, 0, 0.5)'
                            }
                        }
                    }
                ]
            };
            chart.setOption(option);
            window.addEventListener('resize', () => {
                chart.resize();
            });

        }
        const networkReputationScore = (data) => {
            const chart = echarts.init(userSelectors.networkReputationScore);
            const categories = Object.keys(data["Source of Positive MPXR Score"]);

            // Extract corresponding values dynamically
            const positiveValues = categories.map(cat => data["Source of Positive MPXR Score"][cat]);
            const negativeValues = categories.map(cat => data["Source of Negative MPXR Score"][cat]);
            const option = {
                title: {
                    text: 'Network Analysis Reputation Score Percentage',
                    textStyle: {
                        color: '#fff'
                    },
                    margin: 10,
                    left: 'center'
                },
                angleAxis: {
                    type: 'value',
                },


                radiusAxis: {
                    type: 'category',
                    data: categories,
                    z: 10,

                    axisLabel: {
                        interval: 0,
                        fontSize: 12,
                        overflow: 'truncate',
                        width: 80,
                        textStyle: {
                            color: '#fff',
                        }
                    },

                },
                polar: {
                    center: ['50%', '50%'], // Moves the graph down (default is '50%')
                    radius: "50%",
                },
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    position: function (point, params, dom, rect, size) {
                        const tooltipWidth = dom.clientWidth;
                        const tooltipHeight = dom.clientHeight;

                        // Calculate the center position for the tooltip
                        const centerX = size.viewSize[0] / 2 - tooltipWidth / 2;
                        let offsetY = point[1] + 10; // Keep a small offset from the point

                        // If the tooltip overflows on the right, adjust position
                        if (centerX + tooltipWidth > size.viewSize[0]) {
                            offsetX = size.viewSize[0] - tooltipWidth - 10;
                        }

                        // If the tooltip overflows on the bottom, adjust position
                        if (point[1] + tooltipHeight > size.viewSize[1]) {
                            offsetY = point[1] - tooltipHeight - 10;
                        }

                        return [centerX, offsetY]; // Ensure the tooltip is centered horizontally
                    }
                },

                series: [

                    {
                        type: 'bar',
                        data: positiveValues,
                        coordinateSystem: 'polar',
                        name: 'Positive MPXR',
                        stack: 'a',
                        emphasis: {
                            focus: 'series'
                        }
                    },
                    {
                        type: 'bar',
                        data: negativeValues,
                        coordinateSystem: 'polar',
                        name: 'Negative MPXR',
                        stack: 'a',
                        emphasis: {
                            focus: 'series'
                        }
                    }
                ],
                legend: {
                    show: true,
                    orient: 'vertical',
                    right: 0,
                    top: 25,
                    bottom: 20,
                    data: ['Positive MPXR', 'Negative MPXR'],
                    textStyle: {
                        color: '#fff'
                    },

                },

            };
            chart.setOption(option);
            window.addEventListener('resize', () => {
                chart.resize();
            });
        }
        // const numberMpxrPublication = (data) => {
        //     const chart = echarts.init(userSelectors.numberMpxrPublication);

        // }
        const interactionBreakdownNumbers = (data) => {
            const chart = echarts.init(userSelectors.interactionBreakdownNumbers);
            function buildTree(data) {
                return Object.keys(data).map(key => {
                    if (typeof data[key] === 'object' && data[key] !== null) {
                        return { name: key, children: buildTree(data[key]) };
                    } else {
                        return { name: key, value: data[key] };
                    }
                });
            }

            const datas = {
                name: 'User Interactions',
                children: buildTree(data)
            };


            const option = {
                tooltip: {
                    trigger: 'item',
                    triggerOn: 'mousemove'
                },
                series: [
                    {
                        type: 'tree',
                        data: [datas],
                        top: '1%',
                        left: '7%',
                        bottom: '1%',
                        right: '20%',
                        symbolSize: 7,
                        label: {
                            position: 'left',
                            verticalAlign: 'middle',
                            align: 'right',
                            fontSize: 9
                        },
                        leaves: {
                            label: {
                                position: 'right',
                                verticalAlign: 'middle',
                                align: 'left'
                            }
                        },
                        emphasis: {
                            focus: 'descendant'
                        },
                        expandAndCollapse: true,
                        animationDuration: 550,
                        animationDurationUpdate: 750
                    }
                ]
            }
            chart.setOption(option);
            window.addEventListener('resize', () => {
                chart.resize();
            });
        }
        const mpxrFromInteractionPercentage = (data) => {
            const chart = echarts.init(userSelectors.mpxrFromInteractionPercentage);
            const newData = [];

            for (const key in data) {
                newData.push({
                    value: data[key],
                    name: key.charAt(0).toUpperCase() + key.slice(1).replace(/_/g, ' ')
                });
            }
            option = {
                title: {
                    text: 'MPXR From Interaction Percentage',
                    left: 'center',
                    textStyle: {
                        color: '#fff'
                    }
                },
                tooltip: {
                    trigger: 'item',
                    position: function (point, params, dom, rect, size) {
                        const tooltipWidth = dom.clientWidth;
                        const tooltipHeight = dom.clientHeight;

                        // Calculate the center position for the tooltip
                        const centerX = size.viewSize[0] / 2 - tooltipWidth / 2;
                        let offsetY = point[1] + 10; // Keep a small offset from the point

                        // If the tooltip overflows on the right, adjust position
                        if (centerX + tooltipWidth > size.viewSize[0]) {
                            offsetX = size.viewSize[0] - tooltipWidth - 10;
                        }

                        // If the tooltip overflows on the bottom, adjust position
                        if (point[1] + tooltipHeight > size.viewSize[1]) {
                            offsetY = point[1] - tooltipHeight - 10;
                        }

                        return [centerX, offsetY]; // Ensure the tooltip is centered horizontally
                    }
                },
                legend: {
                    orient: 'vertical',
                    left: 'left',
                    top: '10%',
                    textStyle: {
                        color: '#fff'
                    }
                },

                series: [
                    {
                        name: 'Access From',
                        type: 'pie',
                        radius: '60%',
                        top: '15%',
                        data: newData,
                        label: {
                            textStyle: {
                                color: '#fff'
                            }
                        },
                        emphasis: {
                            itemStyle: {
                                shadowBlur: 10,
                                shadowOffsetX: 0,
                                shadowColor: 'rgba(0, 0, 0, 0.5)'
                            }
                        }
                    }
                ]
            };

            chart.setOption(option);
            window.addEventListener('resize', () => {
                chart.resize();
            });

        }
        const mpxrFromRewards = (data) => {
            const chart = echarts.init(userSelectors.mpxrFromRewards);
            const newData = [];

            function flattenObject(obj, prefix = '') {
                for (const key in obj) {
                    const newKey = prefix ? `${prefix} ${key}` : key;
                    if (typeof obj[key] === 'object' && obj[key] !== null && Object.keys(obj[key]).length > 0) {
                        flattenObject(obj[key], newKey);
                    } else if (typeof obj[key] === 'number') {
                        newData.push({
                            value: obj[key],
                            name: newKey.replace(/_/g, ' ').trim()
                        });
                    }
                }
            }

            flattenObject(data);



            const option = {
                title: {
                    text: 'MPXR From Different Rewards',
                    left: 'center',
                    textStyle: {
                        color: '#fff',
                    }
                },
                // tooltip: {
                //     trigger: 'item'
                // },
                legend: {
                    top: '5%',
                    orient: 'horizontal',
                    left: 0,
                    // right: 0,
                    width: '100%',
                    textStyle: {
                        color: '#fff'
                    }

                },


                series: [
                    {
                        name: 'Access From',
                        type: 'pie',
                        top: '0%',
                        radius: ['40%', '57%'],
                        center: ['50%', '70%'],
                        avoidLabelOverlap: false,
                        itemStyle: {
                            borderRadius: 10,
                            borderColor: '#fff',
                            borderWidth: 2
                        },
                        label: {
                            show: false,
                            position: 'center',

                        },
                        emphasis: {
                            label: {
                                show: true,
                                fontSize: 12,
                                fontWeight: 'bold',

                                textStyle: {
                                    color: '#fff',

                                },

                            }
                        },
                        labelLine: {
                            show: false
                        },
                        data: newData
                    }
                ]
            };
            chart.setOption(option);
            window.addEventListener('resize', () => {
                chart.resize();
            });
        }
        const contentConsumptionBreakdown = (data) => {
            const chart = echarts.init(userSelectors.contentConsumptionBreakdown);

            const datasetSource = [
                ['content_type', 'total', 'completed', 'more_than_half', 'less_than_half']
            ];

            let totalCompleted = 0;
            let totalMoreThanHalf = 0;
            let totalLessThanHalf = 0;

            Object.keys(data["Content Consumption Breakdown"]).forEach(key => {
                const item = data["Content Consumption Breakdown"][key];
                datasetSource.push([key, item.total, item.completed, item.more_than_half, item.less_than_half]);
                totalCompleted += item.completed_percentage;
                totalMoreThanHalf += item.more_than_half_percentage;
                totalLessThanHalf += item.less_than_half_percentage;
            });

            // Aggregated pie chart data
            const pieSource = [
                { value: totalCompleted, name: 'Completed' },
                { value: totalMoreThanHalf, name: 'More than Half' },
                { value: totalLessThanHalf, name: 'Less than Half' },

            ];

            const option = {
                title: {
                    text: 'Content Consumption Breakdown',
                    textStyle: {
                        color: '#fff'
                    },
                    left: 'center'
                },
                legend: {
                    textStyle: {
                        color: '#fff'
                    },
                    top: '5%',
                },
                tooltip: {
                    trigger: 'item',
                    showContent: true
                },
                dataset: [
                    { source: datasetSource },
                    { source: pieSource }
                ],

                xAxis: { type: 'value' },
                yAxis: { type: 'category', data: datasetSource.slice(1).map(item => item[0]) },
                grid: {
                    left: '7%',
                    top: '15%',
                    right: '60%',
                    bottom: '10%'
                },
                series: [
                    {
                        name: 'Completed',
                        type: 'bar',
                        stack: 'total',
                        label: { show: true },
                        emphasis: { focus: 'series' },
                        data: datasetSource.slice(1).map(item => item[1]),
                        barWidth: '40%',
                    },
                    {
                        name: 'More than Half',
                        type: 'bar',
                        stack: 'total',
                        label: { show: true },
                        emphasis: { focus: 'series' },
                        data: datasetSource.slice(1).map(item => item[2]),
                        barWidth: '40%',
                    },
                    {
                        name: 'Less than Half',
                        type: 'bar',
                        stack: 'total',
                        label: { show: true },
                        emphasis: { focus: 'series' },
                        data: datasetSource.slice(1).map(item => item[3]),
                        barWidth: '40%',
                    },
                    {
                        type: 'pie',
                        id: 'pie',
                        radius: ['50%', '30%'],
                        center: ['70%', '50%'],
                        emphasis: { focus: 'self' },
                        label: {
                            formatter: '{b}', textStyle: {
                                color: '#fff',
                                overflow: 'truncate',
                                width: 80,

                            }
                        },
                        data: pieSource,

                    }
                ]
            };


            chart.setOption(option);
            window.addEventListener('resize', () => {
                chart.resize();
            });
        }
        const timeSpentByCategory = (data) => {
            const chart = echarts.init(userSelectors.timeSpentByCategory);
            const pieData = data.map(item => ({
                value: Math.round(item["percentage of spent time"]), // Multiply by 100 to scale to a whole number (optional)
                name: item.category
            }));
            const barCategories = []
            const barValues = []
            data.forEach(item => {
                barCategories.push(item.category)
                barValues.push(Math.round(item["percentage of spent time"]))
            })


            const option = {
                title: {
                    text: 'Read Time and Reputation score collected from Time spent by Category',
                    width: '90%',
                    textStyle: {
                        color: '#fff'
                    },
                    left: 'center'
                },
                legend: {
                    textStyle: {
                        color: '#fff'
                    },
                    top: '5%',
                    data: barCategories
                },
                tooltip: {
                    trigger: 'item',
                    showContent: true
                },
                grid: {
                    top: '10%',
                    bottom: '60%',
                    left: '5%',
                    right: '5%',
                },
                xAxis: [
                    {
                        type: 'category',
                        data: barCategories,
                        axisTick: {
                            alignWithLabel: true
                        }
                    }
                ],
                yAxis: [
                    {
                        type: 'value'
                    }
                ],
                series: [
                    {
                        name: 'bar',
                        type: 'bar',
                        barWidth: '40%',
                        data: barValues,
                        colorBy: barCategories,
                        // Position the bar chart at the top
                        emphasis: { focus: 'self' }
                    },
                    {
                        name: 'pie', // Name the pie series for the legend
                        type: 'pie',
                        id: 'pie',
                        center: ['50%', '65%'],
                        radius: '40%',
                        emphasis: { focus: 'self' },
                        label: {
                            textStyle: {
                                color: '#fff',
                                overflow: 'truncate',
                                width: 80
                            }
                        },
                        data: pieData,
                    }
                ]
            };

            chart.setOption(option);
            window.addEventListener('resize', () => {
                chart.resize();
            });
        }
        const userNature = (data) => {
            const chart = echarts.init(userSelectors.userNature);
            const userNature = [
                { name: "Audience User" },
                { name: "Expert Audience" },
                { name: "Novice Audience" },
                { name: "Novic Content Creator" },
                { name: "Expert Content Creator" },
            ]

            const userExpert = [
                { name: "Average Audience" },
                { name: "Intermediate Audience" },
                { name: "Advanced Audience" },
                { name: "Expert Audience" },

            ]
            const updatedUserNature = userNature.map(item =>
                item.name.toLowerCase() === data["User Nature"]["user nature"].toLowerCase()
                    ? { ...item, itemStyle: { borderColor: '#FF6E14', borderWidth: 3 }, label: { fontWeight: 'bold' } }
                    : item
            );

            const updatedUserExpert = userExpert.map(item =>
                item.name.toLowerCase() === data["User Level"].toLowerCase()
                    ? { ...item, itemStyle: { borderColor: '#FF6E14', borderWidth: 3 }, label: { fontWeight: 'bold' } }
                    : item
            );
            console.log(userNature, data["User Nature"]["user nature"],)

            const userExpertiseTree = [
                {
                    name: "User Profile",
                    children: [
                        {
                            name: "User Nature",
                            children: updatedUserNature
                        },
                        {
                            name: "User Expertise Level",
                            children: updatedUserExpert
                        }
                    ]
                }
            ],
                option = {
                    title: {
                        text: 'User Profile Tree',
                        left: 'center',
                        textStyle: { color: '#fff' }
                    },
                    tooltip: { trigger: 'item', formatter: '{b}' },
                    series: [
                        {
                            type: 'tree',
                            data: userExpertiseTree,
                            top: '10%',
                            left: '15%',
                            bottom: '10%',
                            right: '15%',
                            symbol: 'circle',
                            symbolSize: 10,
                            label: {
                                position: 'top',
                                verticalAlign: 'middle',
                                align: 'right',

                                fontSize: 14,
                                color: '#fff',
                            },
                            leaves: {
                                label: {

                                    //   position: 'bottom',
                                    verticalAlign: 'middle',
                                    align: 'left',
                                    color: '#fff',
                                }
                            },
                            expandAndCollapse: true,
                            animationDuration: 750,
                            animationEasing: 'quinticInOut'
                        }
                    ]
                }

            chart.setOption(option);
            window.addEventListener('resize', () => {
                chart.resize();
            });
        }
        const mpxrFromPublication = (data) => {
            const chart = echarts.init(userSelectors.mpxrFromPublication);
            function processData(data) {
                const categories = [];
                const mpxrByData = [];
                const mpxrFromData = [];

                // Process all top-level keys dynamically
                Object.entries(data).forEach(([topKey, topValue]) => {
                    // Handle nested objects differently
                    if (typeof topValue === 'object') {
                        // Check if the value directly contains MPXR By/From
                        if ('MPXR By' in topValue || 'MPXR From' in topValue) {
                            categories.push(topKey);
                            mpxrByData.push(topValue['MPXR By'] || 0);
                            mpxrFromData.push(topValue['MPXR From'] || 0);
                        } else {
                            // Handle double-nested objects
                            Object.entries(topValue).forEach(([subKey, subValue]) => {
                                if (typeof subValue === 'object' && ('MPXR By' in subValue || 'MPXR From' in subValue)) {
                                    categories.push(`${topKey} (${subKey})`);
                                    mpxrByData.push(subValue['MPXR By'] || 0);
                                    mpxrFromData.push(subValue['MPXR From'] || 0);
                                }
                            });
                        }
                    }
                });

                return { categories, mpxrByData, mpxrFromData };
            }

            const { categories, mpxrByData, mpxrFromData } = processData(data);
            const option = {
                title: {
                    text: 'MPXR Distribution',
                    textStyle: {
                        color: '#fff'
                    },
                    left: 'center'
                },
                tooltip: {
                    trigger: 'axis',
                    axisPointer: {
                        type: 'shadow'
                    },
                    formatter: function (params) {
                        let tooltip = params[0].axisValueLabel + '<br/>';
                        params.forEach(param => {
                            tooltip += `${param.seriesName}: ${param.value.toFixed(4)}<br/>`;
                        });
                        return tooltip;
                    }
                },
                legend: {
                    data: ['MPXR By', 'MPXR From'],
                    textStyle: {
                        color: '#fff'
                    },
                    top: '10%'
                },
                grid: {
                    top: '20%',
                    bottom: '3%',

                    containLabel: true
                },
                xAxis: {
                    type: 'value',
                    axisLabel: {
                        color: '#fff',
                        formatter: value => value.toFixed(2)
                    }
                },
                yAxis: {
                    type: 'category',
                    data: categories,

                    axisLabel: {
                        color: '#fff',
                        margin: 30,
                        interval: 0,
                        formatter: function (value) {
                            const chartWidth = chart.getWidth(); // Get the chart's width
                            const maxLength = Math.floor(chartWidth * 0.02);
                            if (value.length > maxLength) {
                                return value.slice(0, maxLength) + '...';
                            }
                            return value;
                        }
                    }
                },
                series: [
                    {
                        name: 'MPXR By',
                        type: 'bar',
                        stack: 'total',
                        label: {
                            show: true,
                            formatter: function (params) {
                                return params.value === 0 ? '' : params.value.toFixed(4);
                            },

                            color: '#fff'
                        },
                        emphasis: {
                            focus: 'series'
                        },
                        data: mpxrByData
                    },
                    {
                        name: 'MPXR From',
                        type: 'bar',
                        stack: 'total',
                        label: {
                            show: true,
                            formatter: value => value.value.toFixed(4),
                            color: '#fff'
                        },
                        emphasis: {
                            focus: 'series'
                        },
                        data: mpxrFromData
                    }
                ]
            };

            chart.setOption(option);
            window.addEventListener('resize', () => {
                chart.resize();
            });
        }
        const associationBreakdown = (data) => {
            const chart = echarts.init(userSelectors.associationBreakdown);
            const categories = Object.keys(data); // MPXR From Comment, MPXR From Social Post
            const immediateData = []
            const monthlyData = []
            categories.forEach(category => {
                immediateData.push(data[category]['Immediate MPXR'] || 0);
                monthlyData.push(data[category]['Monthly MPXR'] || 0);
            });



            const option = {
                title: {
                    text: 'Reputation by Association Breakdown',
                    textStyle: {
                        color: '#fff'
                    },
                    left: 'center'
                },
                tooltip: {
                    trigger: 'axis',
                    axisPointer: {
                        type: 'shadow'
                    }
                },
                label: {
                    textStyle: {
                        color: '#fff'
                    }
                },
                legend: {
                    textStyle: {
                        color: '#fff'
                    },
                    top: '10%'
                },
                grid: {
                    // left: '3%',
                    // right: '4%',
                    top: '19%',
                    bottom: '3%',
                    containLabel: true
                },
                xAxis: {
                    type: 'value',
                    label: {
                        textStyle: {
                            color: '#fff'
                        }
                    }

                },
                yAxis: {
                    type: 'category',
                    data: categories,

                    axisLabel: {
                        interval: 0,
                        formatter: function (value) {
                            const chartWidth = chart.getWidth(); // Get the chart's width
                            const maxLabelLength = Math.floor(chartWidth * 0.02); // 2% of chart width (adjustable)

                            if (value.length > maxLabelLength) {
                                return value.substring(0, maxLabelLength) + '...'; // Show last characters
                            }
                            return value;

                        }
                    }
                },
                series: [
                    {
                        name: 'Immediate MPXR',
                        type: 'bar',
                        barWidth: 90,
                        stack: 'total',
                        label: {
                            show: true
                        },
                        emphasis: {
                            focus: 'series'
                        },
                        data: immediateData
                    },
                    {
                        name: 'Monthly MPXR',
                        type: 'bar',
                        barWidth: 90,
                        stack: 'total',
                        label: {
                            show: true
                        },
                        emphasis: {
                            focus: 'series'
                        },
                        data: monthlyData
                    }
                ]
            };

            chart.setOption(option);
            window.addEventListener('resize', () => {
                chart.resize();
            });
        }
        const interactionBreakdownLists = (data) => {
            const chart = echarts.init(userSelectors.interactionBreakdownLists);

            function truncateText(text) {
                const chartWidth = chart.getWidth(); // Get the chart's width
                const maxLength = Math.floor(chartWidth * 0.02);
                if (text.length <= maxLength) return text;
                return text.substring(0, maxLength - 3) + '...';
            }
            // Function to transform the data into ECharts tree format
            function transformData(data, name = "Interaction") {
                // Handle null or undefined
                if (data === null || data === undefined) {
                    return {
                        name: `${name}`,
                        value: 'N/A'
                    };
                }

                // Handle numeric values - make them leaf nodes
                if (typeof data === 'number') {
                    return {
                        name,
                        value: data
                    };
                }

                // Handle non-object values
                if (typeof data !== 'object') {
                    return {
                        name: `${name}: ${data}`,
                        value: data
                    };
                }

                // Handle arrays
                if (Array.isArray(data)) {
                    return {
                        name,
                        children: data.map((item, index) => transformData(item, `Item ${index}`))
                    };
                }

                // Handle objects
                try {
                    const children = Object.entries(data).map(([key, value]) =>
                        transformData(value, key)
                    ).filter(Boolean);

                    return {
                        name,
                        children: children.length > 0 ? children : undefined
                    };
                } catch (error) {
                    console.error('Error transforming data:', error);
                    return {
                        name: `${name}`,
                        value: 'Error'
                    };
                }
            }

            var datas = transformData(data);
            const option = {
                title: {
                    text: 'Interaction Breakdown in Numbers',
                    textStyle: {
                        color: '#fff',

                    },
                    left: 'center'
                },
                tooltip: {
                    trigger: 'item',
                    triggerOn: 'mousemove',
                    formatter: (params) => {
                        if (typeof params.data.value === 'number') {
                            return `${params.name}: ${params.data.value.toFixed(2)}%`;
                        }
                        return params.name;
                    },

                    position: function (point, params, dom, rect, size) {
                        const tooltipWidth = dom.clientWidth;
                        const tooltipHeight = dom.clientHeight;

                        // Calculate the center position for the tooltip
                        const centerX = size.viewSize[0] / 2 - tooltipWidth / 2;
                        let offsetY = point[1] + 10; // Keep a small offset from the point

                        // If the tooltip overflows on the right, adjust position
                        if (centerX + tooltipWidth > size.viewSize[0]) {
                            offsetX = size.viewSize[0] - tooltipWidth - 10;
                        }

                        // If the tooltip overflows on the bottom, adjust position
                        if (point[1] + tooltipHeight > size.viewSize[1]) {
                            offsetY = point[1] - tooltipHeight - 10;
                        }

                        return [centerX, offsetY]; // Ensure the tooltip is centered horizontally
                    }
                },
                series: [
                    {
                        type: 'tree',
                        data: [datas],
                        top: '1%',
                        left: '7%',
                        bottom: '1%',
                        right: '20%',
                        symbolSize: 7,
                        label: {
                            position: 'left',
                            verticalAlign: 'middle',
                            align: 'right',
                            fontSize: 12,
                            textStyle: {
                                color: '#fff'
                            },
                            formatter: (params) => {
                                const name = params.name;
                                const value = params.data.value;
                                if (typeof value === 'number') {
                                    // Truncate name and add value
                                    return `${truncateText(name)}: ${value.toFixed(1)}%`;
                                }
                                // Just truncate name for non-leaf nodes
                                return truncateText(name);
                            }
                        },
                        leaves: {
                            label: {
                                position: 'right',
                                verticalAlign: 'middle',
                                align: 'left'
                            }
                        },
                        emphasis: {
                            focus: 'descendant'
                        },
                        expandAndCollapse: true,
                        animationDuration: 550,
                        animationDurationUpdate: 750,
                        initialTreeDepth: 2
                    }
                ]
            };
            chart.setOption(option);
            window.addEventListener('resize', () => {
                chart.resize();
            });
        }

        

        async function fetchedUserById(userId) {

            try {

                let data
                if (userId != undefined) {
                    const user = users.find((u) => u.user == parseInt(userId));

                    if (!user) {
                        console.log("post not found");
                    } else {
                        data = user;

                    }
                } else {
                    console.log("id is undefined");
                }

                if (data) {

                    categoricalReputationBreakdown(data.categories)
                    networkReputationScore(data['Network Breakdown'])
                    // numberMpxrPublication(data["Reputation Score Breakdown by number"])
                    userNature(data)
                    mpxrFromInteractionPercentage(data["Total User Interaction Breakdown"]["Total User Percentage of Interactions"])
                    // interactionBreakdownNumbers(data)
                    mpxrFromRewards(data["Reputation Score Breakdown by number"])
                    contentConsumptionBreakdown(data)
                    timeSpentByCategory(data["User Categorical read time Breakdown"])
                    mpxrFromPublication(data["Reputation Score Breakdown by number"])
                    associationBreakdown(data["Association Breakdown"])
                    interactionBreakdownLists(data["Interaction Breakdown Lists"])
                }
            } catch (error) {
                console.error("Error when fetching the data:", error);
            }
        }
        
        fetchedUserById(2);


    </script>
</body>

</html>